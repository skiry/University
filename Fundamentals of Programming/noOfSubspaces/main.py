def backt(poz, val, index, k, subSpaces, whatPos = 1):
    # poz = solutia la fiecare pas
    # val = vectorul de frecventa
    # index = elementul curent
    # k = numarul de linii
    # whatPos = de la ce pozitie incepem cautarea 
    #       urmatorului element(generam valori crescatoare in binar)
    if index == k:
        if isSolution(poz, k, subSpaces):
            subSpaces.append(poz[:])
    elif index < k:
        for i in range(whatPos, len(val) + 1):
            if val[i] == 0:
                poz[index] = i
                val[i] = 1
                backt(poz, val, index + 1, k, subSpaces, i)
                val[i] = 0
                poz[index] = 0

def isSolution(matrix, k, subSpaces):
    # check if the rank of the matrix is k
    # if so, check if is not generated by another subspace

    if rankOfMatrix(generateMatrix(matrix)) != k:
        return False

    for x in subSpaces:
        matrice = []
        for cnt in matrix:
            matrice.append(cnt)

        for j in x:
            matrice.append(j)

        res = generateMatrix(matrice)
        hes = rankOfMatrix(res, True)
        if rankOfMatrix(res, True) == k:
            return False
    return True


        

def rankOfMatrix(matrix, yes = False):
    # compute the rank of a matrix
    global n, k

    if yes:
        n *= 2
    rank = k
    for row in range(0, k):
        # Before we visit current row, we make
        # sure that matrix[row][0],....matrix[row][row-1]
        # are 0.
 
        # Diagonal element is anot zero
        if matrix[row][row]:
            for col in range(0, k):
               if col != row:
                 # This makes all entries of current
                 # column as 0 except entry 'matrix[row][row]'
                 mult = matrix[col][row] // matrix[row][row];
                 for i in range(0, rank):
                   matrix[col][i] -= mult * matrix[row][i];
                   matrix[col][i] = (2 + matrix[col][i]) % 2
  
 
        # Diagonal element is already zero. Two cases arise:

        # 1) If there is a row below it with non-zero
        #    entry, then swap this row with that row
        #    and process that row
        # 2) If all elements in current column below
        #    mat[r][row] are 0, then remvoe this column
        #    by swapping it with last column and
        #    reducing number of columns by 1.
        else:
            reduce = True
 
            # Find the non-zero element in current column
            for i in range(row + 1, k):
                # Swap the row with non-zero element with this row.
                if matrix[i][row]:
                    for cnt in range(0, rank):
                        matrix[row][cnt], matrix[i][cnt] = matrix[i][cnt], matrix[row][cnt]
                    reduce = False;
                    break
 
            # If we did not find any row with non-zero
            # element in current columnm, then all
            # values in this column are 0.
            if reduce:
                # Reduce number of columns
                rank -= 1
 
                # Copy the last column here
                for i in range (0, k):
                    matrix[i][row] = matrix[i][rank];
 
            # Process this row again
            row -= 1

    if yes:
        n //= 2
    return rank

def generateMatrix(dict):
    #generate the matrix from an array with elements. ex: [1,3] : (0, 1)
                                                                # (1, 1)
        global n
        matrix = {} 
        for i in range(0,len(dict)):
                # dict[i] = number
                for x in range(n - 1 , -1, -1):
                        # x-position of every bit
                        res = 2**x
                        if dict[i]&res == res:
                                if i not in matrix:
                                        matrix[i] = [(1)]
                                else:
                                        matrix[i].append(1)
                        else:
                                if i not in matrix:
                                        matrix[i] = [(0)]
                                else:
                                        matrix[i].append(0)
        return matrix

def main():
    global n, k
    try:
        # read N and K
        n = int(input("N = "))
        k = int(input("K = "))
    except Exception:
        print("Integer Values!")

    subSpaces = []
    #the final result
    if n >= k:
        val = {}
        for i in range(1, 2**n): 
        # toate posibilitatile liniilor in binar(=valori)
            val[i] = 0
        poz = [0 for x in range(0,k)]
        backt(poz, val, 0, k, subSpaces)

        for x in subSpaces:
            print(generateMatrix(x))

main()
